import tkinter as tk
from tkinter import messagebox
from tkinter.ttk import Treeview

class Process:
    def __init__(self, pid, arrival_time, burst_time):
        self.pid = pid
        self.arrival_time = arrival_time
        self.burst_time = burst_time
        self.remaining_time = burst_time
        self.completion_time = 0
        self.waiting_time = 0
        self.turnaround_time = 0

class RRScheduler:
    def __init__(self, quantum):
        self.quantum = quantum
        self.processes = []
        self.time = 0
        self.execution_order = []

    def add_process(self, pid, arrival_time, burst_time):
        process = Process(pid, arrival_time, burst_time)
        self.processes.append(process)

    def execute(self):
        ready_queue = []
        self.processes.sort(key=lambda p: p.arrival_time)

        while any(p.remaining_time > 0 for p in self.processes):
            for process in self.processes:
                if process.arrival_time <= self.time and process not in ready_queue and process.remaining_time > 0:
                    ready_queue.append(process)

            if ready_queue:
                current_process = ready_queue.pop(0)
                execution_time = min(current_process.remaining_time, self.quantum)

                self.execution_order.append((self.time, current_process.pid))
                self.time += execution_time
                current_process.remaining_time -= execution_time

                if current_process.remaining_time > 0:
                    ready_queue.append(current_process)
                else:
                    current_process.completion_time = self.time

            else:
                self.time += 1

        for process in self.processes:
            process.turnaround_time = process.completion_time - process.arrival_time
            process.waiting_time = process.turnaround_time - process.burst_time

    def get_metrics(self):
        avg_waiting_time = sum(p.waiting_time for p in self.processes) / len(self.processes)
        avg_turnaround_time = sum(p.turnaround_time for p in self.processes) / len(self.processes)
        return avg_waiting_time, avg_turnaround_time

# GUI Implementation
def simulate():
    try:
        quantum = int(quantum_entry.get())
        if quantum <= 0:
            raise ValueError
    except ValueError:
        messagebox.showerror("Invalid Input", "Quantum must be a positive integer.")
        return

    scheduler = RRScheduler(quantum)
    for child in process_table.get_children():
        pid, arrival_time, burst_time = process_table.item(child, 'values')
        scheduler.add_process(pid, int(arrival_time), int(burst_time))

    scheduler.execute()
    avg_waiting_time, avg_turnaround_time = scheduler.get_metrics()

    result_window = tk.Toplevel(root)
    result_window.title("Simulation Results")

    tk.Label(result_window, text="Execution Order:").pack()
    gantt_chart = tk.Text(result_window, height=5, width=50)
    gantt_chart.pack()

    for start_time, pid in scheduler.execution_order:
        gantt_chart.insert(tk.END, f"[Time {start_time}] -> Process {pid}\n")

    tk.Label(result_window, text=f"Average Waiting Time: {avg_waiting_time:.2f}").pack()
    tk.Label(result_window, text=f"Average Turnaround Time: {avg_turnaround_time:.2f}").pack()

def add_process():
    try:
        pid = pid_entry.get()
        arrival_time = int(arrival_time_entry.get())
        burst_time = int(burst_time_entry.get())
        if arrival_time < 0 or burst_time <= 0:
            raise ValueError
    except ValueError:
        messagebox.showerror("Invalid Input", "Arrival and burst times must be non-negative integers.")
        return

    process_table.insert('', 'end', values=(pid, arrival_time, burst_time))

# Main GUI Setup
root = tk.Tk()
root.title("Round Robin Scheduler")

frame = tk.Frame(root)
frame.pack(pady=10)

# Input Fields
tk.Label(frame, text="Process ID:").grid(row=0, column=0, padx=5)
pid_entry = tk.Entry(frame)
pid_entry.grid(row=0, column=1, padx=5)

tk.Label(frame, text="Arrival Time:").grid(row=1, column=0, padx=5)
arrival_time_entry = tk.Entry(frame)
arrival_time_entry.grid(row=1, column=1, padx=5)

tk.Label(frame, text="Burst Time:").grid(row=2, column=0, padx=5)
burst_time_entry = tk.Entry(frame)
burst_time_entry.grid(row=2, column=1, padx=5)

add_button = tk.Button(frame, text="Add Process", command=add_process)
add_button.grid(row=3, columnspan=2, pady=5)

# Process Table
process_table = Treeview(root, columns=("PID", "Arrival Time", "Burst Time"), show="headings")
process_table.heading("PID", text="Process ID")
process_table.heading("Arrival Time", text="Arrival Time")
process_table.heading("Burst Time", text="Burst Time")
process_table.pack(pady=10)

# Quantum Input
tk.Label(root, text="Quantum:").pack()
quantum_entry = tk.Entry(root)
quantum_entry.pack(pady=5)

# Simulate Button
simulate_button = tk.Button(root, text="Simulate", command=simulate)
simulate_button.pack(pady=10)

if __name__ == "__main__":
    root.mainloop()
