class Process:
    def __init__(self, pid, arrival_time, burst_time):
        self.pid = pid
        self.arrival_time = arrival_time
        self.burst_time = burst_time
        self.remaining_time = burst_time
        self.completion_time = 0
        self.waiting_time = 0
        self.turnaround_time = 0

class RRScheduler:
    def __init__(self, quantum):
        self.quantum = quantum
        self.processes = []
        self.time = 0
        self.execution_order = []

    def add_process(self, pid, arrival_time, burst_time):
        process = Process(pid, arrival_time, burst_time)
        self.processes.append(process)

    def execute(self):
        ready_queue = []
        self.processes.sort(key=lambda p: p.arrival_time)

        while any(p.remaining_time > 0 for p in self.processes):
            for process in self.processes:
                if process.arrival_time <= self.time and process not in ready_queue and process.remaining_time > 0:
                    ready_queue.append(process)

            if ready_queue:
                current_process = ready_queue.pop(0)
                execution_time = min(current_process.remaining_time, self.quantum)

                self.execution_order.append((self.time, current_process.pid))
                self.time += execution_time
                current_process.remaining_time -= execution_time

                if current_process.remaining_time > 0:
                    ready_queue.append(current_process)
                else:
                    current_process.completion_time = self.time

            else:
                self.time += 1

        for process in self.processes:
            process.turnaround_time = process.completion_time - process.arrival_time
            process.waiting_time = process.turnaround_time - process.burst_time

    def get_metrics(self):
        avg_waiting_time = sum(p.waiting_time for p in self.processes) / len(self.processes)
        avg_turnaround_time = sum(p.turnaround_time for p in self.processes) / len(self.processes)
        return avg_waiting_time, avg_turnaround_time

# Example Simulation
if __name__ == "__main__":
    scheduler = RRScheduler(quantum=4)
    scheduler.add_process("P1", 0, 8)
    scheduler.add_process("P2", 1, 4)
    scheduler.add_process("P3", 2, 9)
    scheduler.add_process("P4", 3, 5)

    scheduler.execute()

    print("Execution Order:")
    for time, pid in scheduler.execution_order:
        print(f"[Time {time}] -> Process {pid}")

    avg_waiting_time, avg_turnaround_time = scheduler.get_metrics()
    print(f"Average Waiting Time: {avg_waiting_time:.2f}")
    print(f"Average Turnaround Time: {avg_turnaround_time:.2f}")
